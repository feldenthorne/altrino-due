/** \file system_functions.cpp
 *  This file contains the class for system functions for the CPP version of the ASF
 *  getting_started example.
 */

// Include the header
#include "system_functions.h"

// We need to define the system tick handler separately from the class, otherwise
// the linker can't see it.
/** \brief Handler for System Tick interrupt.
 *  Process System Tick Event
 *  Increments the g_ul_ms_ticks counter.
 *  If we have FreeRTOS enabled, this'll cause issues with the SysTick_Handler provided
 *  in FreeRTOS/Source/portable/GCC/ARM_CM3/port.c, so this needs to be surrounded by
 *  an #ifndef #endif
 */
#ifndef _USE_FREERTOS_
void SysTick_Handler(void)
{
	g_ul_ms_ticks++;
}
#endif

// Additionally, keep the TC0 interrupt handler out of the class because it's externed
// elsewhere and hooked up as the actual ISR function.
/** \brief Interrupt handler for TC0 interrupt. 
 *  Toggles the state of LED\#2.
 */
void TC0_Handler(void)
{
	volatile uint32_t ul_dummy;

	/* Clear status bit to acknowledge interrupt */
	ul_dummy = tc_get_status(TC0, 0);

	/* Avoid compiler warning */
	UNUSED(ul_dummy);

	#ifdef LED1_GPIO
		/** Toggle LED state. */
		ioport_toggle_pin_level(LED1_GPIO);
	#endif

	printf("2 ");
}

// Defines for the system class
/** \brief This constructor really doesn't do much but give access to the class methods.
 */
system_functions::system_functions(void)
{
	// Initialize Button Booleans
	InitializeButtonBools();
	
	// Initialize the object variables and pointers
	g_ul_ms_ticks = 0;
	g_b_led0_active = true;
	g_b_led1_active = true;
}

/** \brief Initialize the system clock with default ASF parameters
 */
void system_functions::init_clock(void)
{
	sysclk_init();
}

/** \brief Initialize the board with default ASF parameters.
 */
void system_functions::init_board(void)
{
	board_init();
}

/** \brief Configure the Pushbuttons
 *  Configure the PIO as inputs and generate corresponding interrupt when
 *  pressed or released.
 */
void system_functions::config_buttons(void)
{
	configure_buttons();
}

/** \brief Configure Timer Counter 0
 *  Generate an interrupt every 250ms
 */
void system_functions::config_tc(void)
{
	uint32_t ul_div;
	uint32_t ul_tcclks;
	uint32_t ul_sysclk = sysclk_get_cpu_hz();

	/* Configure PMC */
	pmc_enable_periph_clk(ID_TC0);

	/** Configure TC for a 4Hz frequency and trigger on RC compare. */
	tc_find_mck_divisor(4, ul_sysclk, &ul_div, &ul_tcclks, ul_sysclk);
	tc_init(TC0, 0, ul_tcclks | TC_CMR_CPCTRG);
	tc_write_rc(TC0, 0, (ul_sysclk / ul_div) / 4);

	/* Configure and enable interrupt on RC compare */
	NVIC_EnableIRQ((IRQn_Type) ID_TC0);
	tc_enable_interrupt(TC0, 0, TC_IER_CPCS);

	#ifdef LED1_GPIO
		/** Start the counter if LED1 is enabled. */
		if (g_b_led1_active) 
		{
			tc_start(TC0, 0);
		}
	#else
		tc_start(TC0, 0);
	#endif
}

/** \brief Configure UART console
 *  Uses options specified in include/configure_console.h
 */
void system_functions::config_console(void)
{
	usart_serial_options_t uart_serial_options =
	{
		.baudrate   = CONF_UART_BAUDRATE,
		.charlength = 8,
		.paritytype = CONF_UART_PARITY,
		.stopbits   = 1
	};

	/* Configure console UART. */
	sysclk_enable_peripheral_clock(CONSOLE_UART_ID);
	stdio_serial_init(CONF_UART, &uart_serial_options);
}

/** \brief Wait for the given number of milliseconds (using the g_ul_ms_ticks
 *  generated by the SAM's microcontrollers's system tick).
 *
 *  \param ul_dly_ticks  Delay to wait for, in milliseconds.
 */
void system_functions::mdelay(uint32_t ul_dly_ticks)
{
	uint32_t ul_cur_ticks;

	ul_cur_ticks = g_ul_ms_ticks;
	while ((g_ul_ms_ticks - ul_cur_ticks) < ul_dly_ticks);
}